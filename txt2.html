<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gboard Editor</title>
<style>
:root {
  --primary: #46526b;
  --bg: #f7f9fc;
  --card: #ffffff;
  --radius: 6px;
  --input-bg: #eef2f7;
  --input-focus: #e0e7ef;
  --border: #dbeafe;
  --highlight: #fff7cc;
  --highlight-text: #bfa31d;
  --shadow: 0 4px 20px rgba(0,0,0,0.08);
}

*, *::before, *::after { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  font-family: 'Segoe UI', Arial, sans-serif;
  background: var(--bg);
  color: #222;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
}

.container {
  width: 100%;
  max-width: 480px;
  margin: 32px 0;
  background: var(--card);
  border-radius: var(--radius);
  padding: 24px 16px;
  box-shadow: var(--shadow);
  display: flex;
  flex-direction: column;
  gap: 20px;
}

h2 {
  margin: 0 0 12px;
  font-weight: 700;
  color: var(--primary);
  font-size: 2rem;
  text-align: center;
}

h3 {
  margin: 16px 0 8px;
  font-size: 1.1rem;
  font-weight: 600;
  color: #222;
}

input[type="file"], textarea, input[type="text"] {
  width: 100%;
  border-radius: var(--radius);
  padding: 12px 14px;
  font-size: 15px;
  border: 1px solid var(--border);
  background: var(--input-bg);
  font-family: monospace;
  transition: all 0.2s ease;
}

input[type="file"] { max-width: 95%; cursor: pointer; margin: auto;}
textarea {
  max-width: 95%;
  margin: auto;
  min-height: 220px;
  resize: vertical;
  box-shadow: 0 2px 10px rgba(37,99,235,0.05);

  white-space: nowrap;   /* line wrap ‡¶¨‡¶®‡ßç‡¶ß */
  overflow-x: auto;      /* horizontal scroll enable */
  overflow-y: auto;      /* vertical scroll ‡¶•‡¶æ‡¶ï‡ßÅ‡¶ï */
}

input[type="file"]:hover,
textarea:focus,
input[type="text"]:focus { background: var(--input-focus); outline: none; }

.undo-redo-reset, .actions, .input-group {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
}

.btn {
  padding: 10px 18px;
  font-size: 15px;
  font-weight: 600;
  background: var(--primary);
  color: #fff;
  border: none;
  border-radius: var(--radius);
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(37,99,235,0.1);
  transition: 0.2s ease;
}

.btn:hover { background: #1742a0; }

#preview {
  min-height: 220px;
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;  /* horizontal scroll on */
  background: var(--input-bg);
  padding: 6px;
  border-radius: var(--radius);
  font-family: monospace;
  font-size: 15px;
  color: #222;
  white-space: nowrap;  /* line wrap off */
  box-shadow: 0 2px 10px rgba(37,99,235,0.05);
}

#preview div {
  display: block;       /* ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø line ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá */
  white-space: nowrap;  /* line ‡¶≠‡ßá‡¶§‡¶∞‡ßá wrap off */
  padding: 2px;
  border-radius: 8px;
  transition: 0.2s;
}
#preview .shortcut {
  font-weight: 700;     /* shortcut-bold */
}

#preview div.selected {  background: #e3f0ff; }
#preview .highlight { background: var(--highlight); color: var(--highlight-text); font-weight: 700; }
#preview .shortcut { display: inline-block; font-weight: 700; padding-right: 8px; min-width: auto; }
#preview .value { flex: 1; }

#stats { font-size: 0.95rem; color: #444; text-align: right; margin-top: 4px; }

::-webkit-scrollbar { width: 6px; background: var(--input-bg); }
::-webkit-scrollbar-thumb { background: #d1d9e6; border-radius: 6px; }
#preview::-webkit-scrollbar { height: 6px; } /* horizontal scrollbar */

@media (max-width:600px){
  .container { max-width: 100vw; padding: 12px 8px; margin: 0; border-radius: 10px; }
  h2 { font-size: 1.5rem; }
  textarea, input[type="text"] { font-size: 14px; padding: 10px; }
  #preview { font-size: 13px; padding: 10px; max-height: 180px; }
  .btn { font-size: 13px; padding: 8px 12px; }
}

@media (max-width:400px){
  .container { padding: 8px 4px; }
  h2 { font-size: 1.2rem; }
  textarea, input[type="text"] { font-size: 12px; padding: 6px 4px; }
  #preview { font-size: 12px; padding: 6px; max-height: 140px; }
  .btn { font-size: 11px; padding: 6px 8px; }
}
.file-upload {
  display: flex;
  align-items: center;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
}

.file-upload input[type="file"] { display: none; }

#fileBtn {
  padding: 10px 18px;
  font-size: 15px;
  font-weight: 600;
  background: var(--primary);
  color: #fff;
  border: none;
  border-radius: var(--radius);
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(37,99,235,0.1);
  transition: 0.2s ease;
}
#fileBtn:hover { background: #1742a0; }

#fileName {
  font-size: 0.9rem;
  color: #555;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}


</style>
</head>
<body>
<div class="container">
  <h2>üìÇ Gboard Dictionary Editor</h2>
<div class="file-upload">
  <input type="file" id="fileInput" accept=".txt,.zip" />
  <button class="btn" id="fileBtn">üìÇ Choose File</button>
  <span id="fileName">No file chosen</span>
</div>

  <textarea id="textArea" placeholder="Your file content will appear here..."></textarea>

  <div class="undo-redo-reset">
    <button class="btn" id="undoBtn">‚Ü© Undo</button>
    <button class="btn" id="redoBtn">‚Ü™ Redo</button>
    <button class="btn" onclick="resetText()">üßπ Reset</button>
    <button class="btn" onclick="refreshPage()">üîÑ Refresh</button>

  </div>

  <div class="actions">
    <button class="btn" onclick="sortLines()">üî§ Sort</button>
    <button class="btn" onclick="removeEmptyLines()">üßΩ Remove Spa</button>
    <button class="btn" onclick="removeDuplicates()">üóÉÔ∏è Remove Dup</button>
    <button class="btn" onclick="removeExtraSpaces()">üßπ Clean Spaces/Tabs</button>
<button class="btn" onclick="formatForGboard()">‚ú® Format for Gboard</button>

    <button class="btn" onclick="downloadFile()">‚¨á Download TXT</button>
    <button class="btn" onclick="downloadZip()">‚¨á Download ZIP</button>
  </div>

  <div class="input-group">
    <input type="text" id="shortcutInput" placeholder="Shortcut" list="shortcutSuggestions" />
    <input type="text" id="valueInput" placeholder="Value" list="valueSuggestions" />
    <button class="btn" onclick="addEntry()">‚ûï Add</button>
  </div>

  <div class="input-group">
    <input type="text" id="shortcutFilter" placeholder="üîç Shortcut..." list="shortcutSuggestions" />
    <input type="text" id="valueFilter" placeholder="üîç Value..." list="valueSuggestions" />
  </div>
  <button class="btn" onclick="clearFilters()">‚ùå Clear Filters</button>

  <h3>üìù Final Preview</h3>
  <div id="preview"></div>
  <div id="stats"></div>

  <datalist id="shortcutSuggestions"></datalist>
  <datalist id="valueSuggestions"></datalist>

  <div class="input-group">
    <input type="text" id="editShortcut" placeholder="Edit Shortcut">
    <input type="text" id="editValue" placeholder="Edit Value">
    <button class="btn" id="applyEditBtn">Apply Edit</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>

const fileInput=document.getElementById('fileInput');
const textArea=document.getElementById('textArea');
const preview=document.getElementById('preview');
const shortcutInput=document.getElementById('shortcutInput');
const valueInput=document.getElementById('valueInput');
const undoBtn=document.getElementById('undoBtn');
const redoBtn=document.getElementById('redoBtn');
const shortcutFilter=document.getElementById('shortcutFilter');
const valueFilter=document.getElementById('valueFilter');
const editShortcut=document.getElementById('editShortcut');
const editValue=document.getElementById('editValue');
const applyEditBtn=document.getElementById('applyEditBtn');
const stats=document.getElementById('stats');
const fileBtn = document.getElementById('fileBtn');
const fileName = document.getElementById('fileName');

let history=[], historyIndex=-1, isUndoRedoAction=false;
let filteredLines=[], selectedIndex=-1;

function saveHistory(){ if(isUndoRedoAction)return; if(historyIndex<history.length-1)history=history.slice(0,historyIndex+1); history.push(textArea.value); historyIndex++; if(history.length>50){history.shift(); historyIndex--;} updateUndoRedoButtons(); }
function updateUndoRedoButtons(){ undoBtn.disabled=historyIndex<=0; redoBtn.disabled=historyIndex>=history.length-1; }
function undo(){ if(historyIndex>0){ isUndoRedoAction=true; textArea.value=history[--historyIndex]; updatePreview(); isUndoRedoAction=false; updateUndoRedoButtons(); }}
function redo(){ if(historyIndex<history.length-1){ isUndoRedoAction=true; textArea.value=history[++historyIndex]; updatePreview(); isUndoRedoAction=false; updateUndoRedoButtons(); }}
function escapeHtml(text){ return text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function updatePreview(){
  const lines = textArea.value.split('\n');
  const counts = {};
  lines.forEach(line => { 
    const sc = line.split('\t')[0]; 
    if(sc) counts[sc] = (counts[sc] || 0) + 1; 
  });

  const sFilter = shortcutFilter.value.toLowerCase();
  const vFilter = valueFilter.value.toLowerCase();
  filteredLines = lines.filter(line => { 
    const parts = line.split('\t'); 
    return (parts[0]?.toLowerCase().includes(sFilter) && parts[1]?.toLowerCase().includes(vFilter)); 
  });

preview.innerHTML = filteredLines.map((line, i) => {
    const parts = line.split('\t');
    const sc = parts[0] || '', val = parts[1] || '';
    const isDup = counts[sc] > 1, isSelected = i === selectedIndex;

    return `<div class="${isSelected ? 'selected' : ''} ${isDup ? 'highlight' : ''}">
      <span class="shortcut">${escapeHtml(sc)}</span>\t
      <span class="value">${escapeHtml(val)}</span>
    </div>`;
}).join('');



  let dup = 0; 
  for(let k in counts) if(counts[k] > 1) dup += counts[k] - 1;
  stats.textContent = `Total Lines: ${lines.length} | Duplicate Shortcuts: ${dup}`;

  updateEditableFields();

  // Scroll selected line in preview ONLY (screen fixed, textarea unaffected)
  if(selectedIndex >= 0){
    const child = preview.children[selectedIndex];
    if(child){
      preview.scrollTop = child.offsetTop - preview.offsetTop;
    }
  }
}


function updateSuggestions(){
  const lines=textArea.value.split('\n');
  const sSet=new Set(), vSet=new Set();
  lines.forEach(line=>{ const p=line.split('\t'); if(p[0]) sSet.add(p[0].trim()); if(p[1]) vSet.add(p[1].trim()); });
  const shortcutList=document.getElementById('shortcutSuggestions');
  const valueList=document.getElementById('valueSuggestions');
  shortcutList.innerHTML=''; valueList.innerHTML='';
  Array.from(sSet).sort().forEach(s=>{ const opt=document.createElement('option'); opt.value=s; shortcutList.appendChild(opt); });
  Array.from(vSet).sort().forEach(v=>{ const opt=document.createElement('option'); opt.value=v; valueList.appendChild(opt); });
}

fileBtn.addEventListener('click', () => {
    fileInput.click();
});

fileInput.addEventListener('change', () => {
    if(fileInput.files.length > 0){
        fileName.textContent = fileInput.files[0].name;
    } else {
        fileName.textContent = "No file chosen";
    }

    const file = fileInput.files[0]; 
    if(!file) return; 
    const reader = new FileReader();
    if(file.name.endsWith('.txt')){
        reader.onload = e => { 
            textArea.value = e.target.result; 
            updatePreview(); 
            saveHistory(); 
            updateSuggestions(); 
        };
        reader.readAsText(file);
    } else if(file.name.endsWith('.zip')){
        reader.onload = e => {
            JSZip.loadAsync(e.target.result).then(zip => {
                const dictFile = zip.file(/dictionary\.txt$/i);
                if(dictFile && dictFile.length>0){
                    dictFile[0].async("string").then(content=>{
                        textArea.value = content; 
                        updatePreview(); 
                        saveHistory(); 
                        updateSuggestions();
                    });
                } else alert("Zip file-‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá dictionary.txt ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø!");
            });
        };
        reader.readAsArrayBuffer(file);
    }
});

function resetText(){ textArea.value=''; updatePreview(); shortcutInput.value=valueInput.value=''; shortcutInput.focus(); }
function refreshPage(){ location.reload(); }
function removeEmptyLines(){ textArea.value=textArea.value.split('\n').filter(l=>l.trim()!=='').join('\n'); updatePreview(); saveHistory(); updateSuggestions(); }
function removeDuplicates(){ const seen=new Set(); textArea.value=textArea.value.split('\n').filter(l=>{ const sc=l.split('\t')[0]; if(seen.has(sc)) return false; seen.add(sc); return true; }).join('\n'); updatePreview(); saveHistory(); updateSuggestions(); }
function removeExtraSpaces(){
  const lines = textArea.value.split('\n');
  const cleaned = lines.map(line => {
    // split by tab or spaces
    const parts = line.split('\t').map(p => p.trim());
    // join back with single tab
    return parts.join('\t');
  });
  textArea.value = cleaned.join('\n');
  updatePreview();
  saveHistory();
  updateSuggestions();
  alert("Extra spaces and tabs removed!");
}


function sortLines(){ const lines=textArea.value.split('\n'); const comments=lines.filter(l=>l.trim().startsWith('#')); const normal=lines.filter(l=>!l.trim().startsWith('#')); normal.sort((a,b)=>a.localeCompare(b)); textArea.value=[...comments,...normal].join('\n'); updatePreview(); saveHistory(); updateSuggestions(); }
function addEntry(){ const sc=shortcutInput.value.trim(); const val=valueInput.value.trim(); if(!sc||!val) return alert('Please enter both shortcut and value.'); textArea.value+=(textArea.value?'\n':'')+`${sc}\t${val}\ten-US\t`; shortcutInput.value=valueInput.value=''; updatePreview(); saveHistory(); updateSuggestions(); shortcutInput.focus(); }
function downloadFile(){ const blob=new Blob([textArea.value],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='edited_document.txt'; a.click(); URL.revokeObjectURL(url); }
function downloadZip(){ const zip=new JSZip(); zip.file("dictionary.txt", textArea.value); zip.generateAsync({type:"blob"}).then(content=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(content); a.download="edited_document.zip"; a.click(); }); }

shortcutFilter.addEventListener('input',()=>{ selectedIndex=-1; updatePreview(); updateSuggestions(); });
valueFilter.addEventListener('input',()=>{ selectedIndex=-1; updatePreview(); updateSuggestions(); });
function clearFilters(){ shortcutFilter.value=valueFilter.value=''; selectedIndex=-1; updatePreview(); updateSuggestions(); }

function updateEditableFields(){
  if(selectedIndex>=0 && filteredLines[selectedIndex]){
    const parts=filteredLines[selectedIndex].split('\t');
    editShortcut.value=parts[0]||''; editValue.value=parts[1]||'';
  } else { editShortcut.value=''; editValue.value=''; }
}

applyEditBtn.addEventListener('click',()=>{
  if(selectedIndex<0) return;
  const lines=textArea.value.split('\n');
  const targetLine=filteredLines[selectedIndex];
  const indexInAll=lines.indexOf(targetLine);
  if(indexInAll<0) return;
  lines[indexInAll]=`${editShortcut.value}\t${editValue.value}\ten-US\t`;
  textArea.value=lines.join('\n');
  updatePreview(); saveHistory(); updateSuggestions();
});

editShortcut.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); applyEditBtn.click(); }});
editValue.addEventListener('keydown',e=>{ if(e.key==='Enter'){ e.preventDefault(); applyEditBtn.click(); }});

function updateEditableFromTextarea(){
  const cursorPos=textArea.selectionStart;
  const lines=textArea.value.split('\n'); 
  let cumulative=0, lineIndex=0;
  for(let i=0;i<lines.length;i++){ cumulative+=lines[i].length+1; if(cursorPos<=cumulative){ lineIndex=i; break; } }
  const line=lines[lineIndex];
  const fi=filteredLines.indexOf(line);
  selectedIndex=fi>=0?fi:-1;
  updatePreview();
  updateEditableFields();
}

textArea.addEventListener('click',updateEditableFromTextarea);
textArea.addEventListener('keyup',updateEditableFromTextarea);

preview.addEventListener('click',e=>{
  const div=e.target.closest('div');
  const index=Array.from(preview.children).indexOf(div);
  if(index>=0){
    selectedIndex=index;
    updatePreview();
    updateEditableFields();
  }
});

window.addEventListener('keydown',e=>{
  if(filteredLines.length>0){
    if(e.key==='ArrowDown'){ e.preventDefault(); selectedIndex=Math.min(selectedIndex+1,filteredLines.length-1); updatePreview(); }
    if(e.key==='ArrowUp'){ e.preventDefault(); selectedIndex=Math.max(selectedIndex-1,0); updatePreview(); }
  }
  if(e.ctrlKey && !e.shiftKey && e.key==='z'){ e.preventDefault(); undo(); }
  else if((e.ctrlKey && e.key==='y')||(e.ctrlKey && e.shiftKey && e.key==='Z')){ e.preventDefault(); redo(); }
});

updatePreview(); updateSuggestions();

function formatForGboard(){
  let lines = textArea.value.split('\n');

  const preserved = [];
  const normalLines = [];

  lines.forEach(line => {
    const trimmed = line.trim();
    // ‡¶Ø‡¶¶‡¶ø ‡¶ï‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá # ‡¶¶‡¶ø‡ßü‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡ßü, ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶•‡¶æ‡¶ï‡ßá
    if(trimmed.startsWith('#') && preserved.length < 2){
      preserved.push(trimmed); // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¶‡ßÅ‡¶á‡¶ü‡¶æ preserve
    } else if(trimmed !== ''){
      normalLines.push(trimmed);
    }
  });

  // process normal lines
  const processed = normalLines.map(line => {
    const parts = line.split('\t').map(p => p.trim());
    if(!parts[2] || parts[2]==='') parts[2] = 'en-US'; // missing language tag
    return `${parts[0]}\t${parts[1]}\t${parts[2]}`;
  });

  // sort by shortcut
  processed.sort((a,b)=>a.localeCompare(b));

  // combine preserved + processed
  const finalLines = [...preserved, ...processed];
  textArea.value = finalLines.join('\n');

  updatePreview();
  saveHistory();
  updateSuggestions();

  alert("‚úÖ Gboard format applied! First 2 comment lines preserved, missing language codes assigned 'en-US'.");
}

</script>
</body>
</html>
